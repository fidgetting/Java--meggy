
/*
 * node.hpp
 *
 * This file is automatically generated, do not change. If a change to this
 * file is needed, please change nodes.in instead.
 */

#ifndef NODE_HPP_INCLUDE
#define NODE_HPP_INCLUDE

#include <string>
#include <vector>

class visitor;

/* ************************************************************************** */
/* *** abstract __node classes ********************************************** */
/* ************************************************************************** */

class __node {
  public:

    __node(std::string name, int line = 0, int poss = 0) :
      _name(name), _line(line), _poss(poss) { }

    virtual ~__node() { };
    virtual void accept(visitor* v) = 0;

    inline int  line() const { return _line; }
    inline int& line()       { return _line; }
    inline int  poss() const { return _poss; }
    inline int& poss()       { return _poss; }

    inline std::string name() const { return _name; }

  protected:

    std::string _name;
    int _line;
    int _poss;
};

struct _i_expr : public __node {
    _i_expr(std::string name) : __node(name) { }
    virtual ~_i_expr() { }
};

struct _i_stmt : public __node {
    _i_stmt(std::string name) : __node(name) { }
    virtual ~_i_stmt() { }
};

struct _i_type : public __node {
    _i_type(std::string name) : __node(name) { }
    virtual ~_i_type() { }
};

class token : public __node {
  public:

    virtual ~token() { }
    virtual void accept(visitor* v);

    inline std::string  txt() const { return _txt; }
    inline std::string& txt()       { return _txt; }

    static token* get(std::string txt, int line, int poss);

  private:

    token(std::string txt, int line, int poss) :
      __node("token", line, poss), _txt(txt) { }

    std::string _txt;
};

/* ************************************************************************** */
/* *** node types *********************************************************** */
/* ************************************************************************** */

class formal : public __node {
  public:
    formal(_i_type* type, token* name) :
      __node("formal "), _type(type),_name(name){ }

    virtual ~formal();
    virtual void accept(visitor* v);
  
    inline _i_type*  type() const { return _type; }
    inline _i_type*& type()       { return _type; }
    inline token*   name() const { return _name; }
    inline token*& name()       { return _name; }
  
  private:
    _i_type* _type;
    token  * _name;
};

class main_c : public __node {
  public:
    main_c(token* name, token* parm, _i_stmt* stmt) :
      __node("main_c "), _name(name),_parm(parm),_stmt(stmt){ }

    virtual ~main_c();
    virtual void accept(visitor* v);
  
    inline token*   name() const { return _name; }
    inline token*& name()       { return _name; }
    inline token*   parm() const { return _parm; }
    inline token*& parm()       { return _parm; }
    inline _i_stmt*  stmt() const { return _stmt; }
    inline _i_stmt*& stmt()       { return _stmt; }
  
  private:
    token  * _name;
    token  * _parm;
    _i_stmt* _stmt;
};

class var_de : public __node {
  public:
    var_de(_i_type* type, token* name) :
      __node("var_de "), _type(type),_name(name){ }

    virtual ~var_de();
    virtual void accept(visitor* v);
  
    inline _i_type*  type() const { return _type; }
    inline _i_type*& type()       { return _type; }
    inline token*   name() const { return _name; }
    inline token*& name()       { return _name; }
  
  private:
    _i_type* _type;
    token  * _name;
};

class method_de : public __node {
  public:
    method_de(_i_type* type, token* name, std::vector<formal*>* parm, std::vector<var_de*>* vars, std::vector<_i_stmt*>* stmt, _i_expr* expr) :
      __node("method_de "), _type(type),_name(name),_parm(parm),_vars(vars),_stmt(stmt),_expr(expr){ }

    virtual ~method_de();
    virtual void accept(visitor* v);
  
    inline _i_type*               type() const { return _type; }
    inline _i_type*&             type()       { return _type; }
    inline token*                 name() const { return _name; }
    inline token*&               name()       { return _name; }
    inline std::vector<formal*>*  parm() const { return _parm; }
    inline std::vector<formal*>*& parm()       { return _parm; }
    inline std::vector<var_de*>*  vars() const { return _vars; }
    inline std::vector<var_de*>*& vars()       { return _vars; }
    inline std::vector<_i_stmt*>*  stmt() const { return _stmt; }
    inline std::vector<_i_stmt*>*& stmt()       { return _stmt; }
    inline _i_expr*               expr() const { return _expr; }
    inline _i_expr*&             expr()       { return _expr; }
  
  private:
    _i_type              * _type;
    token                * _name;
    std::vector<formal*> * _parm;
    std::vector<var_de*> * _vars;
    std::vector<_i_stmt*>* _stmt;
    _i_expr              * _expr;
};

class class_de : public __node {
  public:
    class_de(token* name, std::vector<var_de*>* vars, std::vector<method_de*>* meth) :
      __node("class_de "), _name(name),_vars(vars),_meth(meth){ }

    virtual ~class_de();
    virtual void accept(visitor* v);
  
    inline token*                   name() const { return _name; }
    inline token*&                 name()       { return _name; }
    inline std::vector<var_de*>*    vars() const { return _vars; }
    inline std::vector<var_de*>*&  vars()       { return _vars; }
    inline std::vector<method_de*>*  meth() const { return _meth; }
    inline std::vector<method_de*>*& meth()       { return _meth; }
  
  private:
    token                  * _name;
    std::vector<var_de*>   * _vars;
    std::vector<method_de*>* _meth;
};

class program : public __node {
  public:
    program(main_c* main, std::vector<class_de*>* classes) :
      __node("program "), _main(main),_classes(classes){ }

    virtual ~program();
    virtual void accept(visitor* v);
  
    inline main_c*                 main() const { return _main; }
    inline main_c*&               main()       { return _main; }
    inline std::vector<class_de*>*  classes() const { return _classes; }
    inline std::vector<class_de*>*& classes()       { return _classes; }
  
  private:
    main_c                * _main;
    std::vector<class_de*>* _classes;
};

class minus_e : public _i_expr {
  public:
    minus_e(_i_expr* l_expr, _i_expr* r_expr) :
      _i_expr("minus_e "), _l_expr(l_expr),_r_expr(r_expr){ }

    virtual ~minus_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  l_expr() const { return _l_expr; }
    inline _i_expr*& l_expr()       { return _l_expr; }
    inline _i_expr*  r_expr() const { return _r_expr; }
    inline _i_expr*& r_expr()       { return _r_expr; }
  
  private:
    _i_expr* _l_expr;
    _i_expr* _r_expr;
};

class equal_e : public _i_expr {
  public:
    equal_e(_i_expr* l_expr, _i_expr* r_expr) :
      _i_expr("equal_e "), _l_expr(l_expr),_r_expr(r_expr){ }

    virtual ~equal_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  l_expr() const { return _l_expr; }
    inline _i_expr*& l_expr()       { return _l_expr; }
    inline _i_expr*  r_expr() const { return _r_expr; }
    inline _i_expr*& r_expr()       { return _r_expr; }
  
  private:
    _i_expr* _l_expr;
    _i_expr* _r_expr;
};

class plus_e : public _i_expr {
  public:
    plus_e(_i_expr* l_expr, _i_expr* r_expr) :
      _i_expr("plus_e "), _l_expr(l_expr),_r_expr(r_expr){ }

    virtual ~plus_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  l_expr() const { return _l_expr; }
    inline _i_expr*& l_expr()       { return _l_expr; }
    inline _i_expr*  r_expr() const { return _r_expr; }
    inline _i_expr*& r_expr()       { return _r_expr; }
  
  private:
    _i_expr* _l_expr;
    _i_expr* _r_expr;
};

class mul_e : public _i_expr {
  public:
    mul_e(_i_expr* l_expr, _i_expr* r_expr) :
      _i_expr("mul_e "), _l_expr(l_expr),_r_expr(r_expr){ }

    virtual ~mul_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  l_expr() const { return _l_expr; }
    inline _i_expr*& l_expr()       { return _l_expr; }
    inline _i_expr*  r_expr() const { return _r_expr; }
    inline _i_expr*& r_expr()       { return _r_expr; }
  
  private:
    _i_expr* _l_expr;
    _i_expr* _r_expr;
};

class and_e : public _i_expr {
  public:
    and_e(_i_expr* l_expr, _i_expr* r_expr) :
      _i_expr("and_e "), _l_expr(l_expr),_r_expr(r_expr){ }

    virtual ~and_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  l_expr() const { return _l_expr; }
    inline _i_expr*& l_expr()       { return _l_expr; }
    inline _i_expr*  r_expr() const { return _r_expr; }
    inline _i_expr*& r_expr()       { return _r_expr; }
  
  private:
    _i_expr* _l_expr;
    _i_expr* _r_expr;
};

class lt_e : public _i_expr {
  public:
    lt_e(_i_expr* l_expr, _i_expr* r_expr) :
      _i_expr("lt_e "), _l_expr(l_expr),_r_expr(r_expr){ }

    virtual ~lt_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  l_expr() const { return _l_expr; }
    inline _i_expr*& l_expr()       { return _l_expr; }
    inline _i_expr*  r_expr() const { return _r_expr; }
    inline _i_expr*& r_expr()       { return _r_expr; }
  
  private:
    _i_expr* _l_expr;
    _i_expr* _r_expr;
};

class array_e : public _i_expr {
  public:
    array_e(_i_expr* expr, _i_expr* idx) :
      _i_expr("array_e "), _expr(expr),_idx(idx){ }

    virtual ~array_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
    inline _i_expr*  idx() const { return _idx; }
    inline _i_expr*& idx()       { return _idx; }
  
  private:
    _i_expr* _expr;
    _i_expr* _idx;
};

class button_e : public _i_expr {
  public:
    button_e(token* literal) :
      _i_expr("button_e "), _literal(literal){ }

    virtual ~button_e();
    virtual void accept(visitor* v);
  
    inline token*  literal() const { return _literal; }
    inline token*& literal()       { return _literal; }
  
  private:
    token* _literal;
};

class call_e : public _i_expr {
  public:
    call_e(_i_expr* expr, token* id, std::vector<_i_expr*>* args) :
      _i_expr("call_e "), _expr(expr),_id(id),_args(args){ }

    virtual ~call_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*               expr() const { return _expr; }
    inline _i_expr*&             expr()       { return _expr; }
    inline token*                 id() const { return _id; }
    inline token*&               id()       { return _id; }
    inline std::vector<_i_expr*>*  args() const { return _args; }
    inline std::vector<_i_expr*>*& args()       { return _args; }
  
  private:
    _i_expr              * _expr;
    token                * _id;
    std::vector<_i_expr*>* _args;
};

class cast_e : public _i_expr {
  public:
    cast_e(_i_type* type, _i_expr* expr) :
      _i_expr("cast_e "), _type(type),_expr(expr){ }

    virtual ~cast_e();
    virtual void accept(visitor* v);
  
    inline _i_type*  type() const { return _type; }
    inline _i_type*& type()       { return _type; }
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
  
  private:
    _i_type* _type;
    _i_expr* _expr;
};

class color_e : public _i_expr {
  public:
    color_e(token* literal) :
      _i_expr("color_e "), _literal(literal){ }

    virtual ~color_e();
    virtual void accept(visitor* v);
  
    inline token*  literal() const { return _literal; }
    inline token*& literal()       { return _literal; }
  
  private:
    token* _literal;
};

class id_e : public _i_expr {
  public:
    id_e(token* literal) :
      _i_expr("id_e "), _literal(literal){ }

    virtual ~id_e();
    virtual void accept(visitor* v);
  
    inline token*  literal() const { return _literal; }
    inline token*& literal()       { return _literal; }
  
  private:
    token* _literal;
};

class int_e : public _i_expr {
  public:
    int_e(token* literal) :
      _i_expr("int_e "), _literal(literal){ }

    virtual ~int_e();
    virtual void accept(visitor* v);
  
    inline token*  literal() const { return _literal; }
    inline token*& literal()       { return _literal; }
  
  private:
    token* _literal;
};

class length_e : public _i_expr {
  public:
    length_e(_i_expr* expr) :
      _i_expr("length_e "), _expr(expr){ }

    virtual ~length_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
  
  private:
    _i_expr* _expr;
};

class new_array_e : public _i_expr {
  public:
    new_array_e(_i_type* type, _i_expr* expr) :
      _i_expr("new_array_e "), _type(type),_expr(expr){ }

    virtual ~new_array_e();
    virtual void accept(visitor* v);
  
    inline _i_type*  type() const { return _type; }
    inline _i_type*& type()       { return _type; }
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
  
  private:
    _i_type* _type;
    _i_expr* _expr;
};

class new_e : public _i_expr {
  public:
    new_e(token* literal) :
      _i_expr("new_e "), _literal(literal){ }

    virtual ~new_e();
    virtual void accept(visitor* v);
  
    inline token*  literal() const { return _literal; }
    inline token*& literal()       { return _literal; }
  
  private:
    token* _literal;
};

class not_e : public _i_expr {
  public:
    not_e(_i_expr* expr) :
      _i_expr("not_e "), _expr(expr){ }

    virtual ~not_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
  
  private:
    _i_expr* _expr;
};

class tone_e : public _i_expr {
  public:
    tone_e(token* literal) :
      _i_expr("tone_e "), _literal(literal){ }

    virtual ~tone_e();
    virtual void accept(visitor* v);
  
    inline token*  literal() const { return _literal; }
    inline token*& literal()       { return _literal; }
  
  private:
    token* _literal;
};

class false_e : public _i_expr {
  public:
    false_e() :
      _i_expr("false_e "){ }

    virtual ~false_e();
    virtual void accept(visitor* v);
  
  
  private:
};

class true_e : public _i_expr {
  public:
    true_e() :
      _i_expr("true_e "){ }

    virtual ~true_e();
    virtual void accept(visitor* v);
  
  
  private:
};

class this_e : public _i_expr {
  public:
    this_e() :
      _i_expr("this_e "){ }

    virtual ~this_e();
    virtual void accept(visitor* v);
  
  
  private:
};

class array_asn_s : public _i_stmt {
  public:
    array_asn_s(_i_expr* ref, _i_expr* idx, _i_expr* exp) :
      _i_stmt("array_asn_s "), _ref(ref),_idx(idx),_exp(exp){ }

    virtual ~array_asn_s();
    virtual void accept(visitor* v);
  
    inline _i_expr*  ref() const { return _ref; }
    inline _i_expr*& ref()       { return _ref; }
    inline _i_expr*  idx() const { return _idx; }
    inline _i_expr*& idx()       { return _idx; }
    inline _i_expr*  exp() const { return _exp; }
    inline _i_expr*& exp()       { return _exp; }
  
  private:
    _i_expr* _ref;
    _i_expr* _idx;
    _i_expr* _exp;
};

class asn_s : public _i_stmt {
  public:
    asn_s(token* id, _i_expr* expr) :
      _i_stmt("asn_s "), _id(id),_expr(expr){ }

    virtual ~asn_s();
    virtual void accept(visitor* v);
  
    inline token*   id() const { return _id; }
    inline token*& id()       { return _id; }
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
  
  private:
    token  * _id;
    _i_expr* _expr;
};

class block_s : public _i_stmt {
  public:
    block_s(std::vector<_i_stmt*>* stmts) :
      _i_stmt("block_s "), _stmts(stmts){ }

    virtual ~block_s();
    virtual void accept(visitor* v);
  
    inline std::vector<_i_stmt*>*  stmts() const { return _stmts; }
    inline std::vector<_i_stmt*>*& stmts()       { return _stmts; }
  
  private:
    std::vector<_i_stmt*>* _stmts;
};

class call_s : public _i_stmt {
  public:
    call_s(_i_expr* expr, token* id, std::vector<_i_expr*>* args) :
      _i_stmt("call_s "), _expr(expr),_id(id),_args(args){ }

    virtual ~call_s();
    virtual void accept(visitor* v);
  
    inline _i_expr*               expr() const { return _expr; }
    inline _i_expr*&             expr()       { return _expr; }
    inline token*                 id() const { return _id; }
    inline token*&               id()       { return _id; }
    inline std::vector<_i_expr*>*  args() const { return _args; }
    inline std::vector<_i_expr*>*& args()       { return _args; }
  
  private:
    _i_expr              * _expr;
    token                * _id;
    std::vector<_i_expr*>* _args;
};

class if_s : public _i_stmt {
  public:
    if_s(_i_expr* expr, _i_stmt* then, _i_stmt* els) :
      _i_stmt("if_s "), _expr(expr),_then(then),_els(els){ }

    virtual ~if_s();
    virtual void accept(visitor* v);
  
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
    inline _i_stmt*  then() const { return _then; }
    inline _i_stmt*& then()       { return _then; }
    inline _i_stmt*  els() const { return _els; }
    inline _i_stmt*& els()       { return _els; }
  
  private:
    _i_expr* _expr;
    _i_stmt* _then;
    _i_stmt* _els;
};

class while_s : public _i_stmt {
  public:
    while_s(_i_expr* expr, _i_stmt* stmt) :
      _i_stmt("while_s "), _expr(expr),_stmt(stmt){ }

    virtual ~while_s();
    virtual void accept(visitor* v);
  
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
    inline _i_stmt*  stmt() const { return _stmt; }
    inline _i_stmt*& stmt()       { return _stmt; }
  
  private:
    _i_expr* _expr;
    _i_stmt* _stmt;
};

class bool_t : public _i_type {
  public:
    bool_t() :
      _i_type("bool_t "){ }

    virtual ~bool_t();
    virtual void accept(visitor* v);
  
  
  private:
};

class button_t : public _i_type {
  public:
    button_t() :
      _i_type("button_t "){ }

    virtual ~button_t();
    virtual void accept(visitor* v);
  
  
  private:
};

class byte_t : public _i_type {
  public:
    byte_t() :
      _i_type("byte_t "){ }

    virtual ~byte_t();
    virtual void accept(visitor* v);
  
  
  private:
};

class color_t : public _i_type {
  public:
    color_t() :
      _i_type("color_t "){ }

    virtual ~color_t();
    virtual void accept(visitor* v);
  
  
  private:
};

class int_t : public _i_type {
  public:
    int_t() :
      _i_type("int_t "){ }

    virtual ~int_t();
    virtual void accept(visitor* v);
  
  
  private:
};

class tone_t : public _i_type {
  public:
    tone_t() :
      _i_type("tone_t "){ }

    virtual ~tone_t();
    virtual void accept(visitor* v);
  
  
  private:
};

class void_t : public _i_type {
  public:
    void_t() :
      _i_type("void_t "){ }

    virtual ~void_t();
    virtual void accept(visitor* v);
  
  
  private:
};

class array_t : public _i_type {
  public:
    array_t(_i_type* type) :
      _i_type("array_t "), _type(type){ }

    virtual ~array_t();
    virtual void accept(visitor* v);
  
    inline _i_type*  type() const { return _type; }
    inline _i_type*& type()       { return _type; }
  
  private:
    _i_type* _type;
};

class class_t : public _i_type {
  public:
    class_t(token* name) :
      _i_type("class_t "), _name(name){ }

    virtual ~class_t();
    virtual void accept(visitor* v);
  
    inline token*  name() const { return _name; }
    inline token*& name()       { return _name; }
  
  private:
    token* _name;
};

class m_button_e : public _i_expr {
  public:
    m_button_e(_i_expr* expr) :
      _i_expr("m_button_e "), _expr(expr){ }

    virtual ~m_button_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
  
  private:
    _i_expr* _expr;
};

class m_pixel_g_e : public _i_expr {
  public:
    m_pixel_g_e(_i_expr* x_expr, _i_expr* y_expr) :
      _i_expr("m_pixel_g_e "), _x_expr(x_expr),_y_expr(y_expr){ }

    virtual ~m_pixel_g_e();
    virtual void accept(visitor* v);
  
    inline _i_expr*  x_expr() const { return _x_expr; }
    inline _i_expr*& x_expr()       { return _x_expr; }
    inline _i_expr*  y_expr() const { return _y_expr; }
    inline _i_expr*& y_expr()       { return _y_expr; }
  
  private:
    _i_expr* _x_expr;
    _i_expr* _y_expr;
};

class m_aux_s : public _i_stmt {
  public:
    m_aux_s(_i_expr* expr) :
      _i_stmt("m_aux_s "), _expr(expr){ }

    virtual ~m_aux_s();
    virtual void accept(visitor* v);
  
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
  
  private:
    _i_expr* _expr;
};

class m_pixel_s : public _i_stmt {
  public:
    m_pixel_s(_i_expr* x_expr, _i_expr* y_expr, _i_expr* color) :
      _i_stmt("m_pixel_s "), _x_expr(x_expr),_y_expr(y_expr),_color(color){ }

    virtual ~m_pixel_s();
    virtual void accept(visitor* v);
  
    inline _i_expr*  x_expr() const { return _x_expr; }
    inline _i_expr*& x_expr()       { return _x_expr; }
    inline _i_expr*  y_expr() const { return _y_expr; }
    inline _i_expr*& y_expr()       { return _y_expr; }
    inline _i_expr*  color() const { return _color; }
    inline _i_expr*& color()       { return _color; }
  
  private:
    _i_expr* _x_expr;
    _i_expr* _y_expr;
    _i_expr* _color;
};

class m_tone_s : public _i_stmt {
  public:
    m_tone_s(_i_expr* tone, _i_expr* dura) :
      _i_stmt("m_tone_s "), _tone(tone),_dura(dura){ }

    virtual ~m_tone_s();
    virtual void accept(visitor* v);
  
    inline _i_expr*  tone() const { return _tone; }
    inline _i_expr*& tone()       { return _tone; }
    inline _i_expr*  dura() const { return _dura; }
    inline _i_expr*& dura()       { return _dura; }
  
  private:
    _i_expr* _tone;
    _i_expr* _dura;
};

class m_delay_s : public _i_stmt {
  public:
    m_delay_s(_i_expr* expr) :
      _i_stmt("m_delay_s "), _expr(expr){ }

    virtual ~m_delay_s();
    virtual void accept(visitor* v);
  
    inline _i_expr*  expr() const { return _expr; }
    inline _i_expr*& expr()       { return _expr; }
  
  private:
    _i_expr* _expr;
};


#endif

